var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/#LDR-Factorization","page":"API","title":"LDR Factorization","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LDR\nldr\nldr!\nldrs\nldrs!\nLDRWorkspace\nldr_workspace","category":"page"},{"location":"api/#StableLinearAlgebra.LDR","page":"API","title":"StableLinearAlgebra.LDR","text":"LDR{T<:Number, E<:Real} <: Factorization{T}\n\nRepresents the matrix factorization A P = L D R for a square matrix A which may equivalently be written as A = (L D R) P^-1 = (L D R) P^T.\n\nIn the above L is a unitary matrix, D is a diagonal matrix of strictly positive real numbers, and R is an upper triangular matrix. Lastly, P is a permutation matrix, for which P^-1=P^T.\n\nThis factorization is based on a column-pivoted QR decomposition A P = Q R such that\n\nbeginalign*\nL = Q \nD = vert textrmdiag(R) vert \nR = vert textrmdiag(R) vert^-1 R \nP = P\nendalign*\n\nFields\n\nL::Matrix{T}: The unitary matrix L\nd::Vector{E}: A vector representing the diagonal matrix D\nR::Matrix{T}: The upper triangular matrix R\npᵀ::Vector{Int}: A permutation vector representing the permuation matrix P^T\n\n\n\n\n\n","category":"type"},{"location":"api/#StableLinearAlgebra.ldr","page":"API","title":"StableLinearAlgebra.ldr","text":"ldr(A::AbstractMatrix)\n\nCalculate and return the LDR decomposition for the matrix A.\n\n\n\n\n\nldr(F::LDR)\n\nReturn a new LDR factorization that is a copy of F.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.ldr!","page":"API","title":"StableLinearAlgebra.ldr!","text":"ldr!(F::LDR, A::AbstractMatrix)\n\nCalculate the LDR decomposition F for the matrix A.\n\n\n\n\n\nldr!(F::LDR)\n\nRe-calculate the LDR factorization F in-place based on the current contents of the matrix F.L.\n\n\n\n\n\nldr!(F::LDR, I::UniformScaling)\n\nUpdate the LDR factorization F to reflect the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.ldrs","page":"API","title":"StableLinearAlgebra.ldrs","text":"ldrs(A::AbstractMatrix{T}, N::Int) where {T}\n\nReturn a vector of N LDR factorizations, where each one represent the matrix A.\n\n\n\n\n\nldrs(A::AbstractArray{T,3}) where {T}\n\nReturn a vector of size(A, 3) LDR factorizations, where there is an LDR factorization for each matrix A[:,:,i].\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.ldrs!","page":"API","title":"StableLinearAlgebra.ldrs!","text":"ldrs!(Fs::Vector{LDR{T}}, A::AbstractArray{T,3}) where {T}\n\nUpdate the vector Fs of LDR factorization based on the sequence of matrices contained in A.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.LDRWorkspace","page":"API","title":"StableLinearAlgebra.LDRWorkspace","text":"LDRWorkspace{T<:Number}\n\nA workspace to avoid temporary memory allocations when performing computations with an LDR factorization.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableLinearAlgebra.ldr_workspace","page":"API","title":"StableLinearAlgebra.ldr_workspace","text":"ldr_workspace(A::AbstractMatrix)\nldr_workspace(F::LDR)\nldr_workspace(Fs::Vector{LDR})\n\nReturn a workspace for an LDR factorization that can be used to avoid dynamic memory allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Overloaded-Functions","page":"API","title":"Overloaded Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.size\nBase.copyto!\nLinearAlgebra.mul!\nLinearAlgebra.lmul!\nLinearAlgebra.rmul!\nLinearAlgebra.det","category":"page"},{"location":"api/#Base.size","page":"API","title":"Base.size","text":"size(F::LDR)\nsize(F::LDR, dims)\n\nReturn the size of the LDR decomposition F.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.copyto!","page":"API","title":"Base.copyto!","text":"copyto!(A::AbstractMatrix{T}, F::LDR{T}, ws::LDRWorkspace{T}) where {T}\ncopyto!(A::AbstractMatrix{T}, F::LDR{T};\n        M{T}::AbstractMatrix=similar(A)) where {T}\n\nCopy the matrix represented by the LDR decomposition F into the matrix A.\n\n\n\n\n\ncopyto!(F::LDR{T}, A::AbstractMatrix{T}) where {T}\n\nCopy the matrix A to the LDR factorization F, calculating the LDR factorization to represent A.\n\n\n\n\n\ncopyto!(F′::LDR{T}, F::LDR{T}) where {T}\n\nCopy F LDR factorization to F′.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(A::AbstractMatrix{T}, F::LDR{T}, B::AbstractMatrix{T}, ws::LDRWorkspace{T}) where {T}\nmul!(A::AbstractMatrix{T}, F::LDR{T}, B::AbstractMatrix{T};\n     M::AbstractMatrix{T} = similar(A)) where {T}\n\nCalculate the matrix product A = M B where the matrix M is represented by the LDR factorization F.\n\n\n\n\n\nmul!(F′::LDR{T}, B::AbstractMatrix{T}, F::LDR{T}, ws::LDRWorkspace{T}) where {T}\nmul!(F′::LDR{T}, B::AbstractMatrix{T}, F::LDR{T};\n     M::AbstractMatrix{T}=similar(F.L)) where {T}\n\nCalculate the numerically stable product C = B A where the matrices C and A are represented by the LDR decompositions F′ and F respectively.\n\nAlgorithm\n\nCalculate the matrix product using the procedure\n\nbeginalign*\nC =  BA\n  =  oversetL_1D_1R_1P_1^ToverbraceBL_0D_0R_0P_0^T\n  =  oversetL_2overbraceL_1^phantomdaggeroversetD_2overbraceD_1^phantomdaggeroversetR_2overbraceR_1P_1^TR_0oversetP_2^ToverbraceP_0^T\n  =  L_2D_2R_2P_2^T\nendalign*\n\n\n\n\n\nmul!(F′::LDR{T}, F::LDR{T}, B::AbstractMatrix{T}, ws::LDRWorkspace{T}) where {T}\nmul!(F′::LDR{T}, F::LDR{T}, B::AbstractMatrix{T};\n     M::AbstractMatrix{T}=similar(B)) where {T}\n\nCalculate the numerically stable product C = A B where the matrices C and A are represented by the LDR decompositions F′ and F respectively.\n\nAlgorithm\n\nCalculate the matrix product using the procedure\n\nbeginalign*\nC =  AB\n  =  L_0oversetL_1D_1R_1P_1^ToverbraceD_0R_0P_0^TB\n  =  oversetL_2overbraceL_0L_1^phantomToversetD_2overbraceD_1^phantomToversetR_2overbraceR_1^phantomToversetP_2^ToverbraceP_1^T\n  =  L_2D_2R_2P_2^T\nendalign*\n\n\n\n\n\nmul!(F₃::LDR{T}, F₂::LDR{T}, F₁::LDR{T}, ws::LDRWorkspace{T}) where {T}\nmul!(F₃::LDR{T}, F₂::LDR{T}, F₁::LDR{T};\n     M::AbstractMatrix{T}) where {T}\n\nCalculate the numerically stable product A = B C where each matrix is represented by the LDR decompositions F₃, F₂ and F₁ respectively.\n\nAlgorithm\n\nCalculate the numerically stable matrix product A = B C using the procedure\n\nbeginalign*\nA =  BC\n  =  L_bD_boversetMoverbraceR_bP_b^TL_cD_cR_cP_c^T\n  =  L_bD_boversetMoverbraceMD_cR_cP_c^T\n  =  L_boversetMoverbraceD_bMR_cP_c^T\n  =  oversetL_0D_0R_0P_0^TL_boverbraceMR_cP_c^T\n  =  oversetL_aoverbraceL_bL_0^phantomToversetD_aoverbraceD_0^phantomToversetR_aoverbraceR_0P_0^TR_coversetP_a^ToverbraceP_c^T\n  =  L_aD_aR_aP_a^T\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.lmul!","page":"API","title":"LinearAlgebra.lmul!","text":"lmul!(B::AbstractMatrix{T}, F::LDR{T}, ws::LDRWorkspace{T}) where {T}\nlmul!(B::AbstractMatrix{T}, F::LDR{T};\n      M::AbstractMatrix{T}=similar(B),\n      M′::AbstractMatrix{T}=similar(B),\n      p::AbstractMatrix{Int}=similar(F.pᵀ)) where {T}\n\nCalculate the numerically stable product A = B A where the matrix A is represented by the LDR factorization F, updating F in-place to represent the product B A\n\nAlgorithm\n\nGiven a matrix A represented by an LDR factorization, update the LDR factorization to reflect the matrix product A=BA using the procedure\n\nbeginalign*\nA =  BA\n  =  oversetL_1D_1R_1P_1^ToverbraceBL_0D_0R_0P_0^T\n  =  oversetL_2overbraceL_1^phantomdaggeroversetD_2overbraceD_1^phantomdaggeroversetR_2overbraceR_1P_1^TR_0oversetP_2^ToverbraceP_0^T\n  =  L_2D_2R_2P_2^T\nendalign*\n\n\n\n\n\nlmul!(F₂::LDR{T}, F₁::LDR{T}, ws::LDRWorkspace{T}) where {T}\nlmul!(F₂::LDR{T}, F₁::LDR{T};\n      M::AbstractMatrix{T}=similar(F.L),\n      M′::AbstractMatrix{T}=similar(F.L),\n      p::AbstractVector{Int}=similar(F₁.pᵀ)) where {T}\n\nCalculate the matrix product C = B C represented by the LDR factorization F₂ and F₁ respectively, where F₁ is updated in-place.\n\nAlgorithm\n\nCalculate the numerically stable matrix product C = B C using the procedure\n\nbeginalign*\nC =  B C\n    =  L_bD_boversetMoverbraceR_bP_b^TL_cD_cR_cP_c^T\n    =  L_bD_boversetMoverbraceMD_cR_cP_c^T\n    =  L_boversetMoverbraceD_bMR_cP_c^T\n    =  oversetL_0D_0R_0P_0^TL_boverbraceMR_cP_c^T\n    =  oversetL_coverbraceL_cL_0^phantomToversetD_coverbraceD_0^phantomToversetR_coverbraceR_0P_0^TR_coversetP_c^ToverbraceP_c^T\n    =  L_cD_cR_cP_c^T\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.rmul!","page":"API","title":"LinearAlgebra.rmul!","text":"rmul!(F::LDR{T}, B::AbstractMatrix{T}, ws::LDRWorkspace{T}) where {T}\nrmul!(F::LDR{T}, B::AbstractMatrix{T};\n      M::AbstractMatrix{T}=similar(B),\n      M′::AbstractMatrix{T}=similar(B)) where {T}\n\nCalculate the numerically stable product A = A B where the matrix A is represented by the LDR factorization F, updating F in-place to represent the product A B\n\nAlgorithm\n\nGiven a matrix A represented by an LDR factorization, update the LDR factorization to reflect the matrix product A=AB using the procedure\n\nbeginalign*\nA =  AB\n  =  L_0oversetL_1D_1R_1P_1^ToverbraceD_0R_0P_0^TB\n  =  oversetL_2overbraceL_0L_1^phantomToversetD_2overbraceD_1^phantomToversetR_2overbraceR_1^phantomToversetP_2^ToverbraceP_1^T\n  =  L_2D_2R_2P_2^T\nendalign*\n\n\n\n\n\nrmul!(F₂::LDR{T}, F₁::LDR{T}, ws::LDRWorkspace{T}) where {T}\nrmul!(F₂::LDR{T}, F₁::LDR{T};\n      M::AbstractMatrix{T}=similar(F.L),\n      M′::AbstractMatrix{T}=similar(F.L)) where {T}\n\nCalculate the matrix product B = B C represented by the LDR factorization F₂ and F₁ respectively, where F₂ is updated in-place.\n\nAlgorithm\n\nCalculate the numerically stable matrix product B = B C using the procedure\n\nbeginalign*\nB =  B C\n  =  L_bD_boversetMoverbraceR_bP_b^TL_cD_cR_cP_c^T\n  =  L_bD_boversetMoverbraceMD_cR_cP_c^T\n  =  L_boversetMoverbraceD_bMR_cP_c^T\n  =  oversetL_0D_0R_0P_0^TL_boverbraceMR_cP_c^T\n  =  oversetL_boverbraceL_bL_0^phantomToversetD_boverbraceD_0^phantomToversetR_boverbraceR_0P_0^TR_coversetP_b^ToverbraceP_c^T\n  =  L_bD_bR_bP_b^T\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.det","page":"API","title":"LinearAlgebra.det","text":"det(F::LDR{T}, ws::LDRWorkspace{T}) where {T}\ndet(F::LDR{T}) where {T<:Real}\ndet(F::LDR{T}; M::AbstractMatrix{T}=similar(F.L)) where {T<:Complex}\n\nReturn the determinant of the LDR factorization F.\n\n\n\n\n\n","category":"function"},{"location":"api/#Exported-Functions","page":"API","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"inv!\ninv_IpA!\ninv_UpV!\ninv_invUpV!\nsign_det\nabs_det\nabs_det_ratio","category":"page"},{"location":"api/#StableLinearAlgebra.inv!","page":"API","title":"StableLinearAlgebra.inv!","text":"inv!(A⁻¹::AbstractMatrix{T}, F::LDR{T}, ws::LDRWorkspace{T}) where {T}\ninv!(A⁻¹::AbstractMatrix{T}, F::LDR{T};\n     M::AbstractMatrix{T}=similar(F.L),\n     p::AbstractVector{Int}=similar(F.pᵀ)) where {T}\n\nCalculate the inverse of a matrix A represented of the LDR decomposition F, writing the inverse matrix A⁻¹.\n\n\n\n\n\ninv!(F::LDR{T}, ws::LDRWorkspace{T}) where {T}\ninv!(F::LDR{T};\n     M::AbstractMatrix{T},\n     p::AbstractVector{Int}) where {T}\n\nInvert the LDR decomposition F in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.inv_IpA!","page":"API","title":"StableLinearAlgebra.inv_IpA!","text":"inv_IpA!(G::AbstractMatrix{T}, F::LDR{T}, ws::LDRWorkspace{T};\n         F′::LDR{T}=ldr(F)) where {T}\ninv_IpA!(G::AbstractMatrix{T}, F::LDR{T};\n         F′::LDR{T}=ldr(F),\n         d_min::AbstractVector{T}=similar(F.d),\n         d_max::AbstractVector{T}=similar(F.d),\n         M::AbstractMatrix{T}=similar(F.L),\n         p::AbstractVector{Int}=similar(F.pᵀ)) where {T}\n\nGiven a matrix A represented by the LDR factorization F, calculate the numerically stabalized inverse\n\nG = (I + A)^-1\n\nstoring the result in the matrix G.\n\nAlgorithm\n\nGiven an LDR factorization of A, calculate G = (I + A)^-1 using the procedure\n\nbeginalign*\nG =  left(I+Aright)^-1\n  =  (I+oversetD_aminD_amaxL_aoverbraceD_aR_aP_a^T)^-1\n  =  left(I+L_aD_aminD_amaxR_aP_a^Tright)^-1\n  =  left(leftP_aR_a^-1D_amax^-1+L_aD_aminrightD_amaxR_aP_a^Tright)^-1\n  =  P_aR_a^-1D_amax^-1(oversetL_0D_0R_0P_0^ToverbraceP_aR_a^-1D_amax^-1+L_aD_amin)^-1\n  =  P_aR_a^-1D_amax^-1(L_0D_0R_0P_0^T)^-1\n  =  P_aR_a^-1oversetL_1D_1R_1P_1^ToverbraceD_amax^-1P_0R_0^-1D_0^-1L_0^dagger\n  =  P_aR_a^-1L_1D_1R_1P_1^T\nendalign*\n\nwhere D_min = min(D 1) and D_max = max(D 1)\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.inv_UpV!","page":"API","title":"StableLinearAlgebra.inv_UpV!","text":"inv_UpV!(G::AbstractMatrix{T}, Fᵤ::LDR{T}, Fᵥ::LDR{T}, ws::LDRWorkspace{T};\n         F::LDR{T}=ldr(Fᵥ)) where {T}\ninv_UpV!(G::AbstractMatrix{T}, Fᵤ::LDR{T}, Fᵥ::LDR{T};\n         F::LDR{T}=ldr(Fᵤ),\n         dᵤ_min::AbstractVector{T}=similar(Fᵤ.d),\n         dᵤ_max::AbstractVector{T}=similar(Fᵤ.d),\n         dᵥ_min::AbstractVector{T}=similar(Fᵥ.d),\n         dᵥ_max::AbstractVector{T}=similar(Fᵥ.d),\n         M::AbstractMatrix{T}=similar(Fᵥ.L),\n         M′::AbstractMatrix{T}=similar(Fᵥ.L),\n         M″::AbstractMatrix{T}=similar(Fᵥ.L),\n         p::AbstractVector{Int}=similar(Fᵥ.pᵀ),\n         p′::AbstractVector{Int}=similar(Fᵥ.pᵀ)) where {T}\n\nCalculate the numerically stable inverse G = (U + V)^-1 where the matrices U and V are represented by the LDR factorizations Fᵤ and Fᵥ respectively.\n\nAlgorithm\n\nLetting U = L_u D_u R_u P_u^T and V = L_v D_v R_v P_v^T the inverse matrix G = (U + V)^-1 is calculated using the procedure\n\nbeginalign*\nG =  left(U+Vright)^-1\n  =  oversetD_umaxD_umin(L_uoverbraceD_uR_uP_u^T+oversetD_vminD_vmaxL_voverbraceD_vR_vP_v^T)^-1\n  =  left(L_uD_umaxD_uminR_uP_u^T+L_vD_vminD_vmaxR_vP_v^Tright)^-1\n  =  left(L_uD_umaxleftD_uminR_uP_u^TP_vR_v^-1D_vmax^-1+D_umax^-1L_u^daggerL_vD_vminrightD_vmaxR_vP_v^Tright)^-1\n  =  P_vR_v^-1D_vmax^-1(oversetL_0D_0R_0P_0^ToverbraceD_uminR_uP_u^TP_vR_v^-1D_vmax^-1+D_umax^-1L_u^daggerL_vD_vmin)^-1D_umax^-1L_u^dagger\n  =  P_vR_v^-1D_vmax^-1left(L_0D_0R_0P_0^Tright)^-1D_umax^-1L_u^dagger\n  =  P_vR_v^-1oversetL_1D_1R_1P_1^ToverbraceD_vmax^-1P_0R_0^-1D_0^-1L_0^daggerD_umax^-1L_u^dagger\n  =  P_vR_v^-1L_1D_1R_1P_1^TL_u^dagger\nendalign*\n\nwhere D_textrmmin = min(D1) and D_textrmmax = max(D1)\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.inv_invUpV!","page":"API","title":"StableLinearAlgebra.inv_invUpV!","text":"inv_invUpV!(G::AbstractMatrix{T}, Fᵤ::LDR{T}, Fᵥ::LDR{T}, ws::LDRWorkspace{T};\n            F::LDR{T}=ldr(F)) where {T}\ninv_invUpV!(G::AbstractMatrix{T}, Fᵤ::LDR{T}, Fᵥ::LDR{T};\n            F::LDR{T}=ldr(Fᵤ),\n            dᵤ_min::AbstractVector{T}=similar(Fᵤ.d),\n            dᵤ_max::AbstractVector{T}=similar(Fᵤ.d),\n            dᵥ_min::AbstractVector{T}=similar(Fᵥ.d),\n            dᵥ_max::AbstractVector{T}=similar(Fᵥ.d),\n            M::AbstractMatrix{T}=similar(Fᵥ.L),\n            M′::AbstractMatrix{T}=similar(Fᵥ.L),\n            p::AbstractVector{Int}=similar(Fᵥ.pᵀ),\n            p′::AbstractVector{Int}=similar(Fᵥ.pᵀ)) where {T}\n\nCalculate the numerically stable inverse G = (U^-1 + V)^-1 where the matrices U and V are represented by the LDR factorizations Fᵤ and Fᵥ respectively.\n\nAlgorithm\n\nLetting U = L_u D_u R_u P_u^T and V = L_v D_v R_v P_v^T the inverse matrix G = (U^-1 + V)^-1 is calculated using the procedure\n\nbeginalign*\nG =  left(U^-1+Vright)^-1\n  =  (stackrelD_umaxD_uminL_uoverbraceD_uR_uP_u^T^-1+oversetD_vminD_vmaxL_voverbraceD_vR_vP_v^T)^-1\n  =  left(leftL_uD_umaxD_uminR_uP_u^Tright^-1+L_vD_vminD_vmaxR_vP_v^Tright)^-1\n  =  left(P_uR_u^-1D_umin^-1D_umax^-1L_u^dagger+L_vD_vminD_vmaxR_vP_v^Tright)^-1\n  =  left(P_uR_u^-1D_umin^-1leftD_umax^-1L_u^daggerP_vR_v^-1D_vmax^-1+D_uminR_uP_u^TL_vD_vminrightD_vmaxR_vP_v^Tright)^-1\n  =  P_vR_v^-1D_vmax^-1(oversetL_0D_0R_0P_0^ToverbraceD_umax^-1L_u^daggerP_vR_v^-1D_vmax^-1+D_uminR_uP_u^TL_vD_vmin)^-1D_uminR_uP_u^T\n  =  P_vR_v^-1D_vmax^-1left(L_0D_0R_0P_0^Tright)^-1D_uminR_uP_u^T\n  =  P_vR_v^-1oversetL_1D_1R_1P_1^ToverbraceD_vmax^-1P_0R_0^-1D_0^-1L_0^daggerD_uminR_uP_u^T\n  =  P_vR_v^-1L_1D_1R_1P_1^TR_uP_u^T\nendalign*\n\nwhere D_textrmmin = min(D1) and D_textrmmax = max(D1)\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.sign_det","page":"API","title":"StableLinearAlgebra.sign_det","text":"sign_det(F::LDR{T}, ws::LDRWorkspace{T}) where {T}\nsign_det(F::LDR{T}) where {T<:Real}\nsign_det(F::LDR{T}; M::AbstractMatrix{T}=similar(F.L)) where {T<:Complex}\n\nReturns the sign/phase factor of the determinant for a matrix A represented by the LDR factorization F, which is calculated as\n\ntextrmsgn(det A) = det L cdot left( prod_i R_ii right) cdot det P^T\n\nwhere A = L D RP^T\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.abs_det","page":"API","title":"StableLinearAlgebra.abs_det","text":"abs_det(F::LDR{T}; as_log::Bool=false) where {T}\n\nCalculate the absolute value of determinant of the LDR factorization F. If as_log=true, then the log of the absolute value of the determinant is returned instead.\n\nAlgorithm\n\nGiven an LDR factorization L D RP^T calculate the absolute value of the determinant as\n\nexpleft sum_i log(Di) right\n\nwhere D is a diagonal matrix with strictly positive real matrix elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.abs_det_ratio","page":"API","title":"StableLinearAlgebra.abs_det_ratio","text":"abs_det_ratio(F₂::LDR{T}, F₁::LDR{T}, ws::LDRWorkspace{T};\n              as_log::Bool=false) where {T}\nabs_det_ratio(F₂::LDR{T}, F₁::LDR{T};\n              as_log::Bool=false,\n              p::AbstractVector{Int}=similar(F₁.pᵀ),\n              p′::AbstractVector{Int}=similar(F₁.pᵀ)) where {T}\n\nGiven two matrices A_2 and A_1 represented by the LDR factorizations F₂ and F₁ respectively, calculate the absolute value of the determinant ratio vertdet(A_2A_1)vert in a numerically stable fashion. If as_log=true, then this function instead returns log left( vertdet(A_2A_1)vert right)\n\nAlgorithm\n\nLet A_1 = L_1 D_1 R_1 P_1^T and A_2 = L_2 D_2 R_2 P_1^T be N times N square matrices each represented by their respective LDR factorizations. Let us define perumations p_1^(1) dots p_1^(i) dots p_1^(N) and  p_2^(1) dots p_2^(i) dots p_2^(N) that sort the diagonal elements of D_1 and D_2 from smallest to largest. Then a numerically stable expression for evaulating the absolute value of the determinant ratio is\n\nvert det(A_2A_1) vert = expleft sum_i left( log(D_2p_2^(i))\n- log(D_1p_1^(i)) right) right\n\nkeeping in mind that the diagonal elements of D_1 and D_2 are stictly positive real numbers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Developer-API","page":"API","title":"Developer API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"StableLinearAlgebra.mul_D!\nStableLinearAlgebra.div_D!\nStableLinearAlgebra.lmul_D!\nStableLinearAlgebra.rmul_D!\nStableLinearAlgebra.ldiv_D!\nStableLinearAlgebra.rdiv_D!\nStableLinearAlgebra.mul_P!\nStableLinearAlgebra.inv_P!\nStableLinearAlgebra.sign_P","category":"page"},{"location":"api/#StableLinearAlgebra.mul_D!","page":"API","title":"StableLinearAlgebra.mul_D!","text":"mul_D!(A, d, B)\n\nCalculate the matrix product A = D cdot B where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\nmul_D!(A, B, d)\n\nCalculate the matrix product A = B cdot D where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.div_D!","page":"API","title":"StableLinearAlgebra.div_D!","text":"div_D!(A, d, B)\n\nCalculate the matrix product A = D^-1 cdot B where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\ndiv_D!(A, B, d)\n\nCalculate the matrix product A = B cdot D^-1 where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.lmul_D!","page":"API","title":"StableLinearAlgebra.lmul_D!","text":"lmul_D!(d, M)\n\nIn-place calculation of the matrix product M = D cdot M where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.rmul_D!","page":"API","title":"StableLinearAlgebra.rmul_D!","text":"rmul_D!(M, d)\n\nIn-place calculation of the matrix product M = M cdot D where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.ldiv_D!","page":"API","title":"StableLinearAlgebra.ldiv_D!","text":"ldiv_D!(d, M)\n\nIn-place calculation of the matrix product M = D^-1 cdot M where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.rdiv_D!","page":"API","title":"StableLinearAlgebra.rdiv_D!","text":"rdiv_D!(M, d)\n\nIn-place calculation of the matrix product M = M cdot D^-1 where D is a diagonal matrix represented by the vector d.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.mul_P!","page":"API","title":"StableLinearAlgebra.mul_P!","text":"mul_P!(A, p, B)\n\nEvaluate the matrix product A = P cdot B where P is a permutation matrix represented by the vector of integers p.\n\n\n\n\n\nmul_P!(A, B, p)\n\nEvaluate the matrix product A = B cdot P where P is a permutation matrix represented by the vector of integers p.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.inv_P!","page":"API","title":"StableLinearAlgebra.inv_P!","text":"inv_P!(p⁻¹, p)\n\nCalculate the inverse/transpose P^-1=P^T of a permuation P represented by the vector p, writing the result to p⁻¹.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableLinearAlgebra.sign_P","page":"API","title":"StableLinearAlgebra.sign_P","text":"perm_sign(p::AbstractVector{Int})\n\nCalculate the sign/parity of the permutation, textrmsgn(p) = pm 1\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StableLinearAlgebra","category":"page"},{"location":"#StableLinearAlgebra","page":"Home","title":"StableLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StableLinearAlgebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package exports an LDR matrix factorization type for square matrices, along with a corresponding collection of functions for calculating numerically stable matrix products and matrix inverses.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install StableLinearAlgebra.jl run following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add StableLinearAlgebra","category":"page"}]
}
